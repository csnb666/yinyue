<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>极简音乐工具（稳定版）</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Segoe UI', sans-serif; }
        body { background: #fafafa; padding: 30px 15px; color: #111; }
        .container { 
            max-width: 550px; margin: 0 auto; background: #fff; 
            padding: 40px 25px; border: 1px solid #eee; border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .time { 
            text-align: center; font-size: 17px; color: #666; 
            padding-bottom: 18px; margin-bottom: 25px;
            border-bottom: 1px solid #eee;
        }
        
        .btn { 
            width: 100%; padding: 16px; margin: 10px 0; border: none; 
            border-radius: 3px; font-size: 15px; cursor: pointer; 
            transition: all 0.25s ease;
        }
        .btn.primary { background: #111; color: #fff; }
        .btn.primary:hover { background: #333; transform: translateY(-1px); }
        .btn.secondary { background: #fff; color: #111; border: 1px solid #ddd; }
        .btn.secondary:hover { border-color: #111; background: #f9f9f9; }
        .btn.file-btn { padding: 8px 12px; width: auto; margin-top: 8px; }
        
        /* 加载提示 */
        .loading-box {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #fff; padding: 22px 35px; border-radius: 4px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.1); z-index: 101; display: none;
            text-align: center;
        }
        .loading-spinner {
            width: 24px; height: 24px; margin: 0 auto 12px;
            border: 2px solid #eee; border-top-color: #111; border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { font-size: 15px; color: #333; }
        
        /* 弹窗样式 */
        .prompt-box, .choice-box, .link-prompt-box, .file-path-prompt-box { 
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: #fff; padding: 22px; border-radius: 4px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.1); z-index: 100; display: none; 
            min-width: 280px;
        }
        .prompt-box h3, .choice-box h3, .link-prompt-box h3, .file-path-prompt-box h3 { 
            font-size: 16px; color: #111; margin-bottom: 18px;
            padding-bottom: 8px; border-bottom: 1px solid #eee;
        }
        
        .input-group { margin: 18px 0; }
        .input-group label { 
            display: block; margin-bottom: 7px; color: #444; 
            font-size: 14px;
        }
        .input-group input { 
            width: 100%; padding: 13px; border: 1px solid #ddd; 
            border-radius: 3px; font-size: 14px;
            transition: border 0.2s;
        }
        .input-group input:focus { 
            outline: none; border-color: #111;
        }
        
        /* 提示框 */
        .toast { 
            position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); 
            background: rgba(0,0,0,0.85); color: #fff; padding: 13px 22px; 
            border-radius: 20px; font-size: 14px; z-index: 99; display: none; 
        }
        
        .overlay, .link-overlay, .file-path-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.4); z-index: 98; display: none; 
        }
        
        .choice-scroll { 
            max-height: 280px; overflow-y: auto; padding-right: 8px; 
            margin-top: 12px;
        }
        .choice-scroll::-webkit-scrollbar { width: 5px; }
        .choice-scroll::-webkit-scrollbar-thumb { 
            background: #999; border-radius: 3px;
        }
        .choice-scroll::-webkit-scrollbar-track { background: #f5f5f5; }
        
        #audioPlayer { 
            width: 100%; margin-top: 15px; border: 1px solid #eee; 
            border-radius: 3px;
        }
        #fileInput { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <div class="time" id="currentTime"></div>
        <button class="btn primary" id="mainBtn">打开音乐工具</button>
        <audio id="audioPlayer" controls style="display:none;"></audio>
    </div>
    <!-- 原有弹窗：搜索输入、歌曲选择 -->
    <div class="overlay" id="promptOverlay"></div>
    <div class="prompt-box" id="promptBox">
        <h3 id="promptTitle">搜索歌曲</h3>
        <div class="input-group">
            <label for="songName">歌曲名（可加歌手）</label>
            <input type="text" id="songName" placeholder="例如：晴天 周杰伦" required>
        </div>
        <div class="input-group">
            <label for="showCount">显示数量（1-100）</label>
            <input type="number" id="showCount" value="10" min="1" max="100" required>
        </div>
        <button class="btn primary" id="promptConfirm">确认搜索</button>
        <button class="btn secondary" id="promptCancel">取消</button>
    </div>
    <div class="overlay" id="choiceOverlay"></div>
    <div class="choice-box" id="choiceBox">
        <h3 id="choiceTitle">请选择操作</h3>
        <div class="choice-scroll" id="choiceScroll">
            <div id="choiceList"></div>
        </div>
    </div>
    <!-- 新增弹窗1：输入直链播放（无限制） -->
    <div class="link-overlay" id="linkOverlay"></div>
    <div class="link-prompt-box" id="linkPromptBox">
        <h3 id="linkPromptTitle">输入音乐直链播放</h3>
        <div class="input-group">
            <label for="musicLink">音乐直链</label>
            <input type="text" id="musicLink" placeholder="输入任意音乐直链" required>
        </div>
        <button class="btn primary" id="linkConfirm">确认播放</button>
        <button class="btn secondary" id="linkCancel">取消</button>
    </div>
    <!-- 新增弹窗2：本地文件播放（无限制） -->
    <div class="file-path-overlay" id="filePathOverlay"></div>
    <div class="file-path-prompt-box" id="filePathPromptBox">
        <h3 id="filePathPromptTitle">本地文件播放</h3>
        <div class="input-group">
            <label for="filePath">文件路径</label>
            <input type="text" id="filePath" placeholder="输入文件路径" required>
        </div>
        <div class="input-group">
            <label>或选择本地文件</label>
            <button class="btn secondary file-btn" id="selectFileBtn">选择文件</button>
            <input type="file" id="fileInput">
        </div>
        <button class="btn primary" id="filePathConfirm">确认播放</button>
        <button class="btn secondary" id="filePathCancel">取消</button>
    </div>
    <!-- 加载提示框 -->
    <div class="loading-box" id="loadingBox">
        <div class="loading-spinner"></div>
        <div class="loading-text">正在加载...</div>
    </div>
    <!-- 提示框 -->
    <div class="toast" id="toast"></div>
    <script>
        // 1. 基础工具函数：重点强化复制功能的兼容性
        const util = {
            getCurrentTime() {
                const date = new Date();
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hour = String(date.getHours()).padStart(2, '0');
                const minute = String(date.getMinutes()).padStart(2, '0');
                const second = String(date.getSeconds()).padStart(2, '0');
                return `${year}年${month}月${day}日 ${hour}:${minute}:${second}`;
            },
            getRandomEmoji() {
                const bqt = ["🌠","🎋","🍥","🍡","🍋","🍀","🔰","🙃","💮","🎡","💠","🍁️","🌀"];
                return bqt[Math.floor(Math.random() * bqt.length)];
            },
            toast(msg, duration = 3000) {
                const toastEl = document.getElementById('toast');
                toastEl.textContent = msg;
                toastEl.style.display = 'block';
                setTimeout(() => toastEl.style.display = 'none', duration);
            },
            // 强制使用降级方案（隐藏文本框+execCommand）确保复制成功
            copyToClipboard: function(text, successMsg = '复制成功', failMsg = '复制失败') {
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    textarea.style.position = 'fixed';
                    textarea.style.top = '-9999px';
                    textarea.style.left = '-9999px';
                    document.body.appendChild(textarea);
                    textarea.select();
                    const result = document.execCommand('copy');
                    document.body.removeChild(textarea);
                    if (result) {
                        this.toast(successMsg);
                    } else {
                        this.toast(failMsg);
                        console.error('复制失败（execCommand返回false）');
                    }
                } catch (err) {
                    this.toast(failMsg);
                    console.error('复制异常：', err);
                }
            },
            showLoading() {
                document.getElementById('loadingBox').style.display = 'block';
            },
            hideLoading() {
                document.getElementById('loadingBox').style.display = 'none';
            },
            showChoiceWithControl(title, list, callback) {
                const choiceTitle = document.getElementById('choiceTitle');
                const choiceList = document.getElementById('choiceList');
                const choiceOverlay = document.getElementById('choiceOverlay');
                const choiceBox = document.getElementById('choiceBox');
                
                choiceList.innerHTML = '';
                choiceOverlay.onclick = null;
                
                choiceTitle.textContent = title;
                
                list.forEach((item, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'btn secondary';
                    btn.textContent = item;
                    btn.onclick = () => {
                        callback(index + 1);
                        if (index === 0) {
                            choiceOverlay.style.display = 'none';
                            choiceBox.style.display = 'none';
                        }
                    };
                    choiceList.appendChild(btn);
                });
                
                choiceOverlay.onclick = () => {
                    choiceOverlay.style.display = 'none';
                    choiceBox.style.display = 'none';
                };
                
                choiceOverlay.style.display = 'block';
                choiceBox.style.display = 'block';
            },
            showChoice(title, list) {
                return new Promise((resolve) => {
                    const choiceTitle = document.getElementById('choiceTitle');
                    const choiceList = document.getElementById('choiceList');
                    const choiceOverlay = document.getElementById('choiceOverlay');
                    const choiceBox = document.getElementById('choiceBox');
                    choiceTitle.textContent = title;
                    choiceList.innerHTML = '';
                    list.forEach((item, index) => {
                        const btn = document.createElement('button');
                        btn.className = 'btn secondary';
                        btn.textContent = item;
                        btn.onclick = () => {
                            choiceOverlay.style.display = 'none';
                            choiceBox.style.display = 'none';
                            resolve(index + 1);
                        };
                        choiceList.appendChild(btn);
                    });
                    choiceOverlay.style.display = 'block';
                    choiceOverlay.onclick = () => {
                        choiceOverlay.style.display = 'none';
                        choiceBox.style.display = 'none';
                        resolve(null);
                    };
                    choiceBox.style.display = 'block';
                });
            },
            showPrompt(title, defaultVal = ['', '10']) {
                return new Promise((resolve) => {
                    const promptTitle = document.getElementById('promptTitle');
                    const songNameInput = document.getElementById('songName');
                    const showCountInput = document.getElementById('showCount');
                    const promptOverlay = document.getElementById('promptOverlay');
                    const promptBox = document.getElementById('promptBox');
                    const confirmBtn = document.getElementById('promptConfirm');
                    const cancelBtn = document.getElementById('promptCancel');
                    
                    confirmBtn.removeEventListener('click', () => {});
                    cancelBtn.removeEventListener('click', () => {});
                    
                    promptTitle.textContent = title;
                    songNameInput.value = defaultVal[0] || '';
                    showCountInput.value = defaultVal[1] || '10';
                    const confirmHandler = () => {
                        const songName = songNameInput.value.trim();
                        const showCount = showCountInput.value.trim();
                        if (!songName) { this.toast('请输入歌曲名'); return; }
                        if (isNaN(showCount) || showCount < 1 || showCount > 100) { this.toast('显示数量需为1-100的整数'); return; }
                        promptOverlay.style.display = 'none';
                        promptBox.style.display = 'none';
                        resolve([songName, showCount]);
                    };
                    const cancelHandler = () => {
                        promptOverlay.style.display = 'none';
                        promptBox.style.display = 'none';
                        resolve(null);
                    };
                    confirmBtn.addEventListener('click', confirmHandler);
                    cancelBtn.addEventListener('click', cancelHandler);
                    promptOverlay.style.display = 'block';
                    promptOverlay.onclick = cancelHandler;
                    promptBox.style.display = 'block';
                });
            },
            showLinkPrompt() {
                return new Promise((resolve) => {
                    const linkOverlay = document.getElementById('linkOverlay');
                    const linkPromptBox = document.getElementById('linkPromptBox');
                    const linkConfirm = document.getElementById('linkConfirm');
                    const linkCancel = document.getElementById('linkCancel');
                    const musicLinkInput = document.getElementById('musicLink');
                    
                    linkConfirm.removeEventListener('click', () => {});
                    linkCancel.removeEventListener('click', () => {});
                    
                    const confirmHandler = () => {
                        const link = musicLinkInput.value.trim();
                        if (!link) { this.toast('请输入直链'); return; }
                        linkOverlay.style.display = 'none';
                        linkPromptBox.style.display = 'none';
                        resolve(link);
                    };
                    const cancelHandler = () => {
                        linkOverlay.style.display = 'none';
                        linkPromptBox.style.display = 'none';
                        resolve(null);
                    };
                    musicLinkInput.value = '';
                    linkConfirm.addEventListener('click', confirmHandler);
                    linkCancel.addEventListener('click', cancelHandler);
                    linkOverlay.style.display = 'block';
                    linkOverlay.onclick = cancelHandler;
                    linkPromptBox.style.display = 'block';
                });
            },
            showFilePathPrompt() {
                return new Promise((resolve) => {
                    const filePathOverlay = document.getElementById('filePathOverlay');
                    const filePathPromptBox = document.getElementById('filePathPromptBox');
                    const filePathConfirm = document.getElementById('filePathConfirm');
                    const filePathCancel = document.getElementById('filePathCancel');
                    const selectFileBtn = document.getElementById('selectFileBtn');
                    const fileInput = document.getElementById('fileInput');
                    const filePathInput = document.getElementById('filePath');
                    
                    filePathConfirm.removeEventListener('click', () => {});
                    filePathCancel.removeEventListener('click', () => {});
                    selectFileBtn.onclick = null;
                    fileInput.onchange = null;
                    
                    selectFileBtn.onclick = () => fileInput.click();
                    fileInput.onchange = (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            resolve(file); 
                            filePathOverlay.style.display = 'none';
                            filePathPromptBox.style.display = 'none';
                            fileInput.value = '';
                        }
                    };
                    const confirmHandler = () => {
                        const path = filePathInput.value.trim();
                        if (!path) { this.toast('请输入文件路径'); return; }
                        filePathOverlay.style.display = 'none';
                        filePathPromptBox.style.display = 'none';
                        resolve({ type: 'path', value: path });
                    };
                    const cancelHandler = () => {
                        filePathOverlay.style.display = 'none';
                        filePathPromptBox.style.display = 'none';
                        resolve(null);
                        fileInput.value = '';
                    };
                    filePathInput.value = '';
                    filePathConfirm.addEventListener('click', confirmHandler);
                    filePathCancel.addEventListener('click', cancelHandler);
                    filePathOverlay.style.display = 'block';
                    filePathOverlay.onclick = cancelHandler;
                    filePathPromptBox.style.display = 'block';
                });
            },
            storage: {
                get(key) {
                    const val = localStorage.getItem(key);
                    return val ? JSON.parse(val) : null;
                },
                set(key, val) {
                    localStorage.setItem(key, JSON.stringify(val));
                }
            }
        };
        // 2. 音乐核心功能：确保所有变量作用域明确
        const music = {
            state: {
                sel: null,
                gqlb: ["请先搜索歌曲"],
                idb: ["1010"],
                configKey: "musicToolConfig",
                currentAudioUrl: "",
                downloadPath: "/storage/emulated/0/AndroLua/Download/obj/wo3DlMOGwrbDjj7DisKw/",
                tempFileUrl: "",
                proxyUrl: "https://api.codetabs.com/v1/proxy/?quest="
            },
            init() {
                this.state.sel = util.storage.get(this.state.configKey) || ["", "10"];
                window.onbeforeunload = () => {
                    if (this.state.tempFileUrl) URL.revokeObjectURL(this.state.tempFileUrl);
                };
            },
            async searchSong(name, limit) {
                try {
                    const originUrl = `http://music.163.com/api/search/get?s=${encodeURIComponent(name)}&type=1&offset=0&total=true&limit=${limit}`;
                    const proxyRequestUrl = this.state.proxyUrl + encodeURIComponent(originUrl);
                    
                    const res = await fetch(proxyRequestUrl);
                    if (!res.ok) throw new Error(`状态码：${res.status}`);
                    return await res.json();
                } catch (err) {
                    util.toast(`搜索失败：${err.message}`);
                    return null;
                }
            },
            parseSongData(jsonData, searchName, limit) {
                if (!jsonData || !jsonData.result) return false;
                const songCount = jsonData.result.songCount || 0;
                const showCount = songCount < limit ? songCount : limit;
                this.state.gqlb = [];
                this.state.idb = [];
                for (let i = 0; i < showCount; i++) {
                    const song = jsonData.result.songs[i];
                    const singer = song.artists[0].name;
                    const duration = Math.floor(song.duration / 1000);
                    const timeStr = `${Math.floor(duration / 60)}:${String(duration % 60).padStart(2, '0')}`;
                    this.state.gqlb.push(`${song.name} - ${singer}（${timeStr}）`);
                    this.state.idb.push(song.id);
                }
                return `找到《${searchName}》相关歌曲${songCount}首（显示前${showCount}首）`;
            },
            playSong(id, name) {
                this.stopSong();
                this.state.currentAudioUrl = `https://music.163.com/song/media/outer/url?id=${id}.mp3`;
                const audio = document.getElementById('audioPlayer');
                audio.src = this.state.currentAudioUrl;
                audio.style.display = 'block';
                audio.play().then(() => util.toast(`正在播放：${name}`))
                    .catch(err => util.toast(`播放失败：${err.message}`));
            },
            async playByLink(link) {
                this.stopSong();
                util.showLoading();
                const audio = document.getElementById('audioPlayer');
                try {
                    this.state.currentAudioUrl = link;
                    audio.src = link;
                    audio.style.display = 'block';
                    await audio.play();
                    util.toast('直链播放中');
                } catch (err) {
                    util.toast(`播放失败：${err.message}`);
                } finally {
                    util.hideLoading();
                }
            },
            playByFile(fileInfo) {
                this.stopSong();
                const audio = document.getElementById('audioPlayer');
                if (this.state.tempFileUrl) {
                    URL.revokeObjectURL(this.state.tempFileUrl);
                    this.state.tempFileUrl = "";
                }
                if (fileInfo instanceof File) {
                    this.state.tempFileUrl = URL.createObjectURL(fileInfo);
                    audio.src = this.state.tempFileUrl;
                    audio.style.display = 'block';
                    audio.play().then(() => util.toast(`正在播放文件：${fileInfo.name}`))
                        .catch(err => util.toast(`文件播放失败：${err.message}`));
                } else if (fileInfo?.type === 'path') {
                    audio.src = fileInfo.value;
                    audio.style.display = 'block';
                    audio.play().then(() => util.toast(`按路径播放中`))
                        .catch(err => util.toast(`路径播放失败：${err.message}`));
                }
            },
            stopSong() {
                const audio = document.getElementById('audioPlayer');
                audio.pause();
                audio.src = '';
                this.state.currentAudioUrl = "";
                if (this.state.tempFileUrl) {
                    URL.revokeObjectURL(this.state.tempFileUrl);
                    this.state.tempFileUrl = "";
                }
                audio.style.display = 'none';
                util.toast('已停止播放');
            },
            async playHotSong() {
                util.showLoading();
                try {
                    const res = await fetch('https://api.uomg.com/api/rand.music?sort=热歌榜&format=json');
                    if (!res.ok) throw new Error('获取热歌失败');
                    const data = await res.json();
                    if (!data.data || !data.data.url) throw new Error('热歌链接无效');
                    this.stopSong();
                    this.state.currentAudioUrl = data.data.url;
                    const audio = document.getElementById('audioPlayer');
                    audio.src = data.data.url;
                    audio.style.display = 'block';
                    await audio.play();
                    util.toast(`热歌推荐：${data.data.name} - ${data.data.singer}`);
                } catch (err) {
                    util.toast(`热歌播放失败：${err.message}`);
                } finally {
                    util.hideLoading();
                }
            },
            async selectAndPlay() {
                if (this.state.gqlb.length === 0 || this.state.gqlb[0] === "请先搜索歌曲") {
                    util.toast('请先搜索歌曲');
                    return;
                }
                const songIndex = await util.showChoice('选择歌曲', this.state.gqlb);
                if (!songIndex) return;
                
                const selectedSong = this.state.gqlb[songIndex - 1];
                const selectedSongId = this.state.idb[songIndex - 1];
                const songUrl = `https://music.163.com/song/media/outer/url?id=${selectedSongId}.mp3`;
                const downloadPath = this.state.downloadPath;
                const _this = this;
                
                util.showChoiceWithControl(`操作：${selectedSong}`, [
                    '1. 播放歌曲',
                    '2. 复制音乐直链',
                    '3. 复制下载保存路径'
                ], function(actionIndex) {
                    switch (actionIndex) {
                        case 1:
                            _this.playSong(selectedSongId, selectedSong);
                            break;
                        case 2:
                            util.copyToClipboard(songUrl, '音乐直链复制成功', '音乐直链复制失败');
                            break;
                        case 3:
                            util.copyToClipboard(downloadPath, '下载路径复制成功', '下载路径复制失败');
                            break;
                    }
                });
            },
            async searchAndShow() {
                const input = await util.showPrompt('搜索歌曲', this.state.sel);
                if (!input) return;
                const [searchName, showCount] = input;
                util.storage.set(this.state.configKey, [searchName, showCount]);
                this.state.sel = [searchName, showCount];
                util.showLoading();
                const songData = await this.searchSong(searchName, showCount);
                util.hideLoading();
                if (!songData) return;
                const title = this.parseSongData(songData, searchName, showCount);
                if (title) await this.selectAndPlay();
            }
        };
        // 3. 主应用逻辑
        const app = {
            async mainMenu() {
                const emoji = util.getRandomEmoji();
                const menuTitle = `${emoji} 极简音乐工具 ${emoji}`;
                const choice = await util.showChoice(menuTitle, [
                    "1. 搜索歌曲",
                    "2. 选择已搜歌曲",
                    "3. 播放热歌",
                    "4. 停止播放",
                    "5. 输入直链播放",
                    "6. 本地文件播放",
                    "7. 刷新菜单"
                ]);
                switch (choice) {
                    case 1:
                        await music.searchAndShow();
                        break;
                    case 2:
                        await music.selectAndPlay();
                        break;
                    case 3:
                        await music.playHotSong();
                        break;
                    case 4:
                        music.stopSong();
                        break;
                    case 5:
                        const link = await util.showLinkPrompt();
                        if (link) await music.playByLink(link);
                        break;
                    case 6:
                        const fileInfo = await util.showFilePathPrompt();
                        if (fileInfo) music.playByFile(fileInfo);
                        break;
                    case 7:
                        await this.mainMenu();
                        break;
                }
            },
            init() {
                music.init();
                const updateTime = () => {
                    document.getElementById('currentTime').textContent = util.getCurrentTime();
                };
                updateTime();
                setInterval(updateTime, 1000);
                document.getElementById('mainBtn').addEventListener('click', async () => {
                    await this.mainMenu();
                });
            }
        };
        window.onload = () => {
            app.init();
        };
    </script>
</body>
</html>
